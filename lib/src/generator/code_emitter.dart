/// Code Emitter for Bridge Generator.
///
/// Generates Dart source code for BridgedClass implementations
/// from transformed metadata.
library;

import 'generator_config.dart';
import 'transform_pipeline.dart';

// =============================================================================
// CODE EMITTER
// =============================================================================

/// Emits Dart code for bridged classes.
class CodeEmitter {
  final GeneratorConfig config;

  CodeEmitter({required this.config});

  /// Emits code for a single class.
  String emitSingleClass(BridgeableClass cls) {
    final buffer = StringBuffer();
    final indent = config.codeStyle.indent;

    // Header comment
    if (config.codeStyle.generateDocs) {
      buffer.writeln('/// Generated bridge for ${cls.name}.');
      buffer.writeln('///');
      buffer.writeln(
          '/// This file was auto-generated by D4rt Bridge Generator.');
      buffer.writeln('/// Do not modify by hand.');
    }
    buffer.writeln();

    // Imports
    buffer.writeln("import 'package:d4rt/d4rt.dart';");
    buffer.writeln(
        "import 'package:d4rt/d4rt.dart' show BridgeInstanceValidation;");
    for (final import_ in config.additionalImports) {
      buffer.writeln("import '$import_';");
    }
    buffer.writeln();

    // Bridge class definition
    buffer.writeln('/// Bridge definition for [${cls.name}].');
    buffer.writeln('final ${_bridgeVarName(cls.name)} = BridgedClass(');
    buffer.writeln("$indent name: '${cls.name}',");
    buffer.writeln('$indent nativeType: ${cls.nativeType},');

    // Constructors
    if (cls.constructors.isNotEmpty) {
      buffer.writeln('$indent constructors: {');
      for (final ctor in cls.constructors) {
        _emitConstructor(buffer, ctor, cls.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Methods (includes operators as special methods)
    if (cls.methods.isNotEmpty) {
      buffer.writeln('$indent methods: {');
      for (final method in cls.methods) {
        _emitMethod(buffer, method, cls, indent);
      }
      buffer.writeln('$indent},');
    }

    // Getters
    if (cls.getters.isNotEmpty) {
      buffer.writeln('$indent getters: {');
      for (final getter in cls.getters) {
        _emitGetter(buffer, getter, cls, indent);
      }
      buffer.writeln('$indent},');
    }

    // Setters
    if (cls.setters.isNotEmpty) {
      buffer.writeln('$indent setters: {');
      for (final setter in cls.setters) {
        _emitSetter(buffer, setter, cls, indent);
      }
      buffer.writeln('$indent},');
    }

    // Static methods
    if (cls.staticMethods.isNotEmpty) {
      buffer.writeln('$indent staticMethods: {');
      for (final method in cls.staticMethods) {
        _emitStaticMethod(buffer, method, cls.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Static getters
    if (cls.staticGetters.isNotEmpty) {
      buffer.writeln('$indent staticGetters: {');
      for (final getter in cls.staticGetters) {
        _emitStaticGetter(buffer, getter, cls.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Static setters
    if (cls.staticSetters.isNotEmpty) {
      buffer.writeln('$indent staticSetters: {');
      for (final setter in cls.staticSetters) {
        _emitStaticSetter(buffer, setter, cls.name, indent);
      }
      buffer.writeln('$indent},');
    }

    buffer.writeln(');');

    return buffer.toString();
  }

  /// Emits code for a single enum.
  String emitSingleEnum(BridgeableEnum enm) {
    final buffer = StringBuffer();
    final indent = config.codeStyle.indent;

    // Header comment
    if (config.codeStyle.generateDocs) {
      buffer.writeln('/// Generated bridge for ${enm.name} enum.');
      buffer.writeln('///');
      buffer.writeln(
          '/// This file was auto-generated by D4rt Bridge Generator.');
      buffer.writeln('/// Do not modify by hand.');
    }
    buffer.writeln();

    // Imports
    buffer.writeln("import 'package:d4rt/d4rt.dart';");
    buffer.writeln(
        "import 'package:d4rt/d4rt.dart' show BridgeInstanceValidation;");
    for (final import_ in config.additionalImports) {
      buffer.writeln("import '$import_';");
    }
    buffer.writeln();

    // Bridge enum definition
    buffer.writeln('/// Bridge definition for [${enm.name}] enum.');
    buffer.writeln(
        'final ${_bridgeVarName(enm.name)} = BridgedEnumDefinition<${enm.name}>(');
    buffer.writeln("$indent name: '${enm.name}',");
    buffer.writeln('$indent values: ${enm.name}.values,');

    // Getters
    if (enm.getters.isNotEmpty) {
      buffer.writeln('$indent getters: {');
      for (final getter in enm.getters) {
        _emitEnumGetter(buffer, getter, enm.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Methods
    if (enm.methods.isNotEmpty) {
      buffer.writeln('$indent methods: {');
      for (final method in enm.methods) {
        _emitEnumMethod(buffer, method, enm.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Static getters
    if (enm.staticGetters.isNotEmpty) {
      buffer.writeln('$indent staticGetters: {');
      for (final getter in enm.staticGetters) {
        _emitStaticGetter(buffer, getter, enm.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Static methods
    if (enm.staticMethods.isNotEmpty) {
      buffer.writeln('$indent staticMethods: {');
      for (final method in enm.staticMethods) {
        _emitStaticMethod(buffer, method, enm.name, indent);
      }
      buffer.writeln('$indent},');
    }

    // Static setters
    if (enm.staticSetters.isNotEmpty) {
      buffer.writeln('$indent staticSetters: {');
      for (final setter in enm.staticSetters) {
        _emitStaticSetter(buffer, setter, enm.name, indent);
      }
      buffer.writeln('$indent},');
    }

    buffer.writeln(');');

    return buffer.toString();
  }

  /// Emits registration code for all bridges.
  String emitRegistration(
    List<BridgeableClass> classes,
    List<BridgeableEnum> enums,
    List<BridgeableFunction> functions, {
    String libraryUri = 'package:generated/bridges.dart',
  }) {
    final buffer = StringBuffer();
    final indent = config.codeStyle.indent;

    if (config.codeStyle.generateDocs) {
      buffer.writeln('/// Registers all generated bridges with D4rt.');
    }
    buffer.writeln('void registerAllBridges(D4rt interpreter) {');

    // Classes
    for (final cls in classes) {
      buffer.writeln(
          "$indent interpreter.registerBridgedClass(${_bridgeVarName(cls.name)}, '$libraryUri');");
    }

    // Enums
    for (final enm in enums) {
      buffer.writeln(
          "$indent interpreter.registerBridgedEnum(${_bridgeVarName(enm.name)}, '$libraryUri');");
    }

    // Functions
    for (final func in functions) {
      buffer.writeln(
          "$indent interpreter.registertopLevelFunction('${func.name}', ${_bridgeVarName(func.name)}Func);");
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  // -------------------------------------------------------------------------
  // EMISSION HELPERS
  // -------------------------------------------------------------------------

  void _emitConstructor(
    StringBuffer buffer,
    BridgeableConstructor ctor,
    String className,
    String indent,
  ) {
    final name = ctor.name.isEmpty ? '' : ctor.name;
    buffer.writeln(
        "$indent$indent '$name': (visitor, positionalArgs, namedArgs) {");

    _emitCountChecks(buffer, ctor.parameters,
        name.isEmpty ? className : '$className.$name', '$indent$indent$indent');

    buffer.writeln('$indent$indent$indent return ${ctor.callTemplate};');
    buffer.writeln('$indent$indent },');
  }

  void _emitMethod(
    StringBuffer buffer,
    BridgeableMethod method,
    BridgeableClass cls,
    String indent,
  ) {
    buffer.writeln(
        "$indent$indent '${method.name}': (visitor, target, positionalArgs, namedArgs) {");

    _emitCountChecks(buffer, method.parameters, '${cls.name}.${method.name}',
        '$indent$indent$indent');

    // Use asTarget<T>() to properly type the target
    final typeArgs = cls.typeArguments != null ? '<${cls.typeArguments}>' : '';
    final typedClassName = '${cls.name}$typeArgs';
    final typedTarget = "target.asTarget<$typedClassName>('${cls.name}')";

    if (method.hasReturn) {
      if (method.isAsync) {
        final typeArgs =
            method.typeArguments != null ? '<${method.typeArguments}>' : '';
        buffer.writeln(
            '$indent$indent$indent return $typedTarget.${method.name}$typeArgs(');
        _emitCallArgs(
            buffer, method.parameters, '$indent$indent$indent$indent');
        buffer.writeln('$indent$indent$indent );');
      } else {
        // Replace 'target' in callTemplate with typed target
        // Handle unary operators specially: they use (target) format
        final String typedCallTemplate;
        if (method.callTemplate.startsWith('-(target)') ||
            method.callTemplate.startsWith('~(target)')) {
          // Unary operators: replace (target) with (typedTarget)
          typedCallTemplate =
              method.callTemplate.replaceFirst('(target)', '($typedTarget)');
        } else {
          typedCallTemplate = method.callTemplate.replaceFirst(
            'target',
            typedTarget,
          );
        }
        buffer.writeln('$indent$indent$indent return $typedCallTemplate;');
      }
    } else {
      // Replace 'target' in callTemplate with typed target
      final String typedCallTemplate;
      if (method.callTemplate.startsWith('-(target)') ||
          method.callTemplate.startsWith('~(target)')) {
        typedCallTemplate =
            method.callTemplate.replaceFirst('(target)', '($typedTarget)');
      } else {
        typedCallTemplate = method.callTemplate.replaceFirst(
          'target',
          typedTarget,
        );
      }
      buffer.writeln('$indent$indent$indent $typedCallTemplate;');
      buffer.writeln('$indent$indent$indent return null;');
    }

    buffer.writeln('$indent$indent },');
  }

  void _emitGetter(
    StringBuffer buffer,
    BridgeableGetter getter,
    BridgeableClass cls,
    String indent,
  ) {
    final typeArgs = cls.typeArguments != null ? '<${cls.typeArguments}>' : '';
    final typedClassName = '${cls.name}$typeArgs';
    final typedTarget = "target.asTarget<$typedClassName>('${cls.name}')";
    buffer.writeln("$indent$indent '${getter.name}': "
        '(visitor, target) => $typedTarget.${getter.name},');
  }

  void _emitSetter(
    StringBuffer buffer,
    BridgeableSetter setter,
    BridgeableClass cls,
    String indent,
  ) {
    final typeArgs = cls.typeArguments != null ? '<${cls.typeArguments}>' : '';
    final typedClassName = '${cls.name}$typeArgs';
    final typedTarget = "target.asTarget<$typedClassName>('${cls.name}')";
    final coercedValue =
        "value.coerce<${setter.parameterType}>('${setter.name}')";
    buffer.writeln("$indent$indent '${setter.name}': "
        '(visitor, target, value) => $typedTarget.${setter.name} = $coercedValue,');
  }

  void _emitStaticMethod(
    StringBuffer buffer,
    BridgeableMethod method,
    String className,
    String indent,
  ) {
    buffer.writeln(
        "$indent$indent '${method.name}': (visitor, positionalArgs, namedArgs) {");

    _emitCountChecks(buffer, method.parameters, '$className.${method.name}',
        '$indent$indent$indent');

    final typeArgs =
        method.typeArguments != null ? '<${method.typeArguments}>' : '';
    if (method.hasReturn) {
      buffer.writeln(
          '$indent$indent$indent return $className.${method.name}$typeArgs(');
      _emitCallArgs(buffer, method.parameters, '$indent$indent$indent$indent');
      buffer.writeln('$indent$indent$indent );');
    } else {
      buffer
          .writeln('$indent$indent$indent $className.${method.name}$typeArgs(');
      _emitCallArgs(buffer, method.parameters, '$indent$indent$indent$indent');
      buffer.writeln('$indent$indent$indent );');
      buffer.writeln('$indent$indent$indent return null;');
    }

    buffer.writeln('$indent$indent },');
  }

  void _emitStaticGetter(
    StringBuffer buffer,
    BridgeableGetter getter,
    String className,
    String indent,
  ) {
    buffer.writeln("$indent$indent '${getter.name}': "
        '(visitor) => $className.${getter.name},');
  }

  void _emitStaticSetter(
    StringBuffer buffer,
    BridgeableSetter setter,
    String className,
    String indent,
  ) {
    final coercedValue =
        "value.coerce<${setter.parameterType}>('${setter.name}')";
    buffer.writeln("$indent$indent '${setter.name}': "
        '(visitor, value) => $className.${setter.name} = $coercedValue,');
  }

  void _emitEnumGetter(
    StringBuffer buffer,
    BridgeableGetter getter,
    String enumName,
    String indent,
  ) {
    final typedTarget = "target.asTarget<$enumName>('$enumName')";
    buffer.writeln("$indent$indent '${getter.name}': (visitor, target) => "
        "$typedTarget.${getter.name},");
  }

  void _emitEnumMethod(
    StringBuffer buffer,
    BridgeableMethod method,
    String enumName,
    String indent,
  ) {
    buffer.writeln(
        "$indent$indent '${method.name}': (visitor, target, positionalArgs, namedArgs) {");

    _emitCountChecks(buffer, method.parameters, '$enumName.${method.name}',
        '$indent$indent$indent');

    // Use asTarget<T>() to properly type the target
    final typedTarget = "target.asTarget<$enumName>('$enumName')";

    if (method.hasReturn) {
      if (method.isAsync) {
        buffer.writeln(
            '$indent$indent$indent return $typedTarget.${method.name}(');
        _emitCallArgs(
            buffer, method.parameters, '$indent$indent$indent$indent');
        buffer.writeln('$indent$indent$indent );');
      } else {
        // Replace 'target' in callTemplate with typed target
        final String typedCallTemplate;
        if (method.callTemplate.startsWith('-(target)') ||
            method.callTemplate.startsWith('~(target)')) {
          // Unary operators: replace (target) with (typedTarget)
          typedCallTemplate =
              method.callTemplate.replaceFirst('(target)', '($typedTarget)');
        } else {
          typedCallTemplate = method.callTemplate.replaceFirst(
            'target',
            typedTarget,
          );
        }
        buffer.writeln('$indent$indent$indent return $typedCallTemplate;');
      }
    } else {
      // Replace 'target' in callTemplate with typed target
      final String typedCallTemplate;
      if (method.callTemplate.startsWith('-(target)') ||
          method.callTemplate.startsWith('~(target)')) {
        typedCallTemplate =
            method.callTemplate.replaceFirst('(target)', '($typedTarget)');
      } else {
        typedCallTemplate = method.callTemplate.replaceFirst(
          'target',
          typedTarget,
        );
      }
      buffer.writeln('$indent$indent$indent $typedCallTemplate;');
      buffer.writeln('$indent$indent$indent return null;');
    }

    buffer.writeln('$indent$indent },');
  }

  void _emitCountChecks(
    StringBuffer buffer,
    List<BridgeableParameter> parameters,
    String context,
    String indent,
  ) {
    // Positional checks
    final positionalParams = parameters.where((p) => !p.isNamed).toList();
    if (positionalParams.isNotEmpty) {
      final minRequired = positionalParams.where((p) => p.isRequired).length;
      final total = positionalParams.length;

      if (minRequired == total) {
        buffer.writeln(
            '$indent positionalArgs.requireExactCount($total, \'$context\');');
      } else {
        buffer.writeln(
            '$indent positionalArgs.requireCount($minRequired, \'$context\');');
      }
    }

    // Named checks
    final requiredNamed = parameters
        .where((p) => p.isNamed && p.isRequired)
        .map((p) => "'${p.name}'")
        .toList();

    if (requiredNamed.isNotEmpty) {
      buffer.writeln(
          "$indent namedArgs.requireKeys([${requiredNamed.join(', ')}], '$context');");
    }
  }

  void _emitCallArgs(
    StringBuffer buffer,
    List<BridgeableParameter> params,
    String indent,
  ) {
    for (final param in params) {
      if (param.isNamed) {
        final expr = _coerceExpression(param.extractionExpr, param.type);
        buffer.writeln('$indent ${param.name}: $expr,');
      } else {
        final expr = _coerceExpression(param.extractionExpr, param.type);
        buffer.writeln('$indent $expr,');
      }
    }
  }

  /// Checks if a type is a Function type (e.g., "Function", "Callable", "InterpretedFunction").
  bool _isFunctionType(String type) {
    return type.contains('Function') ||
        type == 'Callable' ||
        type == 'InterpretedFunction' ||
        type.endsWith(' Function(') ||
        type.contains('Function(');
  }

  /// Checks if a type name is a generic type parameter (single uppercase letter or multi-letter).
  bool _isGenericParameter(String type) {
    // Check if it looks like a generic parameter (T, R, E, U, K, V, etc)
    // Single uppercase letters or multi-letter patterns like K2, V3, etc.
    return type.isNotEmpty &&
        type[0].toUpperCase() == type[0] &&
        type.length <= 3 && // T, R, E, K, V, K2, V3, etc
        !type.contains('<') &&
        !type.contains('(') &&
        !type.contains(')');
  }

  /// Checks if a type contains generic parameters that can't be used in type expressions.
  bool _hasGenericParameters(String type) {
    // Check for generic parameters in the type string
    return RegExp(r'[A-Z]\d?').hasMatch(type) &&
        (type.contains('Function') || type.contains('('));
  }

  /// Wraps an expression with appropriate type coercion for generic parameters.
  String _coerceExpression(String expr, String type) {
    // Don't wrap if it's already a wrapped function (check for lambda arrow)
    if (expr.contains('=>')) {
      // Already wrapped, return as-is
      return expr;
    }

    // Function types need to be wrapped in closures that call the Callable
    if (_isFunctionType(type)) {
      return _wrapFunctionParameter(expr, type);
    }

    if (_hasGenericParameters(type)) {
      // For function types with generic parameters like "R Function(T)"
      // we need to use dynamic casting and coercion
      return "($expr).coerce<dynamic>('parameter')";
    }
    if (_isGenericParameter(type)) {
      // For simple generic parameters like T, R, E, etc., use dynamic
      return "($expr).coerce<dynamic>('parameter')";
    }
    return expr;
  }

  /// Wraps a Callable in a native Dart function closure.
  /// Receives expressions like "(positionalArgs[0] as Callable)"
  /// and wraps them with a function closure.
  String _wrapFunctionParameter(String expr, String type) {
    // Parse the function type to determine parameters
    // Examples: "void Function()", "dynamic Function(int)", "bool Function(int, String)"

    // For void Function() - no return, no args
    if (type == 'void Function()' || type == 'Function()') {
      return '() => $expr.call(visitor, [])';
    }

    // For Function with single parameter
    if (type.contains('Function(') && !type.contains(',')) {
      return '(arg) => $expr.call(visitor, [arg])';
    }

    // For Function with multiple parameters (e.g., "bool Function(int, String)")
    // Try to count parameters
    final paramCount = type.split(',').length;
    if (paramCount == 2) {
      return '(arg1, arg2) => $expr.call(visitor, [arg1, arg2])';
    }
    if (paramCount == 3) {
      return '(arg1, arg2, arg3) => $expr.call(visitor, [arg1, arg2, arg3])';
    }

    // Default: single parameter
    return '(arg) => $expr.call(visitor, [arg])';
  }

  String _bridgeVarName(String className) {
    // Convert PascalCase to camelCase and add 'Bridged' suffix
    final camel = className[0].toLowerCase() + className.substring(1);
    return '${camel}Bridge';
  }
}

// =============================================================================
// TEMPLATE ENGINE (Alternative approach)
// =============================================================================

/// Simple template engine for code generation.
class TemplateEngine {
  /// Renders a template with the given variables.
  static String render(String template, Map<String, dynamic> variables) {
    var result = template;

    for (final entry in variables.entries) {
      final placeholder = '{{${entry.key}}}';
      final value = entry.value?.toString() ?? '';
      result = result.replaceAll(placeholder, value);
    }

    // Handle conditional blocks: {{#if condition}}...{{/if}}
    result = _processConditionals(result, variables);

    // Handle loops: {{#each items}}...{{/each}}
    result = _processLoops(result, variables);

    return result;
  }

  static String _processConditionals(
      String template, Map<String, dynamic> variables) {
    final pattern =
        RegExp(r'\{\{#if\s+(\w+)\}\}(.*?)\{\{/if\}\}', dotAll: true);

    return template.replaceAllMapped(pattern, (match) {
      final condition = match.group(1)!;
      final content = match.group(2)!;
      final value = variables[condition];

      if (value == true ||
          (value is String && value.isNotEmpty) ||
          (value is List && value.isNotEmpty)) {
        return content;
      }
      return '';
    });
  }

  static String _processLoops(String template, Map<String, dynamic> variables) {
    final pattern =
        RegExp(r'\{\{#each\s+(\w+)\}\}(.*?)\{\{/each\}\}', dotAll: true);

    return template.replaceAllMapped(pattern, (match) {
      final listName = match.group(1)!;
      final itemTemplate = match.group(2)!;
      final items = variables[listName];

      if (items is! List) return '';

      final buffer = StringBuffer();
      for (var i = 0; i < items.length; i++) {
        final item = items[i];
        var rendered = itemTemplate;

        if (item is Map<String, dynamic>) {
          for (final entry in item.entries) {
            rendered =
                rendered.replaceAll('{{${entry.key}}}', entry.value.toString());
          }
        } else {
          rendered = rendered.replaceAll('{{this}}', item.toString());
        }

        rendered = rendered.replaceAll('{{@index}}', i.toString());
        rendered = rendered.replaceAll('{{@first}}', (i == 0).toString());
        rendered = rendered.replaceAll(
            '{{@last}}', (i == items.length - 1).toString());

        buffer.write(rendered);
      }

      return buffer.toString();
    });
  }
}

// =============================================================================
// CODE TEMPLATES
// =============================================================================

/// Pre-defined templates for bridge code generation.
class BridgeTemplates {
  /// Template for a BridgedClass definition.
  static const classTemplate = '''
/// Generated bridge for {{className}}.
final {{varName}} = BridgedClass(
  name: '{{className}}',
  nativeType: {{nativeType}},
  constructors: {
{{#each constructors}}
    '{{name}}': (visitor, positionalArgs, namedArgs) {
      return {{callTemplate}};
    },
{{/each}}
  },
  methods: {
{{#each methods}}
    '{{name}}': (visitor, target, positionalArgs, namedArgs) {
      {{#if hasReturn}}return {{/if}}{{callTemplate}};
    },
{{/each}}
  },
  getters: {
{{#each getters}}
    '{{name}}': (visitor, target) => (target as dynamic).{{name}},
{{/each}}
  },
{{#if hasSetters}}
  setters: {
{{#each setters}}
    '{{name}}': (visitor, target, value) => (target as dynamic).{{name}} = value,
{{/each}}
  },
{{/if}}
{{#if hasOperators}}
  operators: {
{{#each operators}}
    '{{mapKey}}': (visitor, target, positionalArgs, namedArgs) {
      return {{callTemplate}};
    },
{{/each}}
  },
{{/if}}
);
''';

  /// Template for a BridgedEnumDefinition.
  static const enumTemplate = '''
/// Generated bridge for {{enumName}} enum.
final {{varName}} = BridgedEnumDefinition<{{enumName}}>(
  name: '{{enumName}}',
  values: {{enumName}}.values,
{{#if hasGetters}}
  getters: {
{{#each getters}}
    '{{name}}': (visitor, target) => (target as {{enumName}}).{{name}},
{{/each}}
  },
{{/if}}
{{#if hasMethods}}
  methods: {
{{#each methods}}
    '{{name}}': (visitor, target, positionalArgs, namedArgs) {
      return (target as {{enumName}}).{{name}}({{callArgs}});
    },
{{/each}}
  },
{{/if}}
);
''';

  /// Template for registration function.
  static const registrationTemplate = '''
/// Registers all generated bridges with D4rt interpreter.
void registerAllBridges(D4rt interpreter) {
{{#each classes}}
  interpreter.registerBridgedClass({{varName}}, '{{libraryUri}}');
{{/each}}
{{#each enums}}
  interpreter.registerBridgedEnum({{varName}}, '{{libraryUri}}');
{{/each}}
{{#each functions}}
  interpreter.registertopLevelFunction('{{name}}', {{funcVar}});
{{/each}}
}
''';
}
